# 4.2 卷积神经网络

- #### 问题引入

  - 参数过多：神经网络中多个神经元可以组成一层，这一层的神经元需要和上一层的输出做全连接，当然在输入的时候，也需要将输入数据的每一个分量都连接到自己的神经元上作为输入，然后得到一个输出。

    如果是图像的话，我们可以把每一个像素点，都当成一个特征值。

    ![image.png](https://upload-images.jianshu.io/upload_images/7220971-d4cf4e9254a3455c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    参数过多会带来什么问题呢：

    - 容易过拟合，需要更多训练数据（关于更多过拟合的讨论请参考：https://www.jianshu.com/p/c1cd49555a3d）
    - 收敛到较差的局部极值

- #### 卷积 -- 参考https://www.jianshu.com/p/d0890947153c

  - 解决问题

    对于图像数据来说，某个像素点和他周围的关系比较大，但是离他比较远的店的关系就比较小。所以对于一个图像数据来说，他具有非常大的区域性。

    基于这样的一个性质，我们可以做一个筛检，从全连接编程局部链接从而降低他的模型参数

    （注：区域连接范围是只一个区域的大小是10\*10，不是将1000\*1000的图像分成100份）

    - 局部连接（图像的区域性）

      ![image.png](https://upload-images.jianshu.io/upload_images/7220971-2155ae0071598243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

      当然还可以去调整filter-size：神经元和图像中多大的区域的像素点进行连接

    - 参数共享（图像特征与位置无关）

      对于一张图像来说，不同的角度可以看到不同的图像信息。图像的特征和位置是无关的，他的特征就代表着这个东西是什么（比如爱因斯坦的左眼和右眼）；和位置无关，就代表着说可以在图像的任何一个位置（可能是左上角，可能是右上角），如果用每个神经元去学习一个固定的位置的话，那么这个神经元他提取的特征，他也不知道是什么，因为这个位置是变化的，所以说我们无法去解释这个神经元到底学到了什么东西。

      为了解决这个问题，我们又做了另外一个操作-参数共享：强制每一个神经元和图像的局部链接都使用同样的参数。

      先看下这么做可以降低模型参数到什么程度

      ![image.png](https://upload-images.jianshu.io/upload_images/7220971-175be8783f0312f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

      那么这个的物理含义是什么呢：以下图为例，左边是原图，右边是原图的每一个区域根据参数块内积得到的神经元，可以想象成是参数再在图像上从左到右从上到下划过生成的一个新的图像。那么可以想象一下参数共享的含义。不管这个特征在哪（图像的哪个位置），这个参数块就是去捕捉这个特征，捕捉到了，就可以激活对应的某个神经元(每个参数块由所有局部区域共享，为提取一个特征)

      ![image.png](https://upload-images.jianshu.io/upload_images/7220971-23cbea3402be749b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  - 每个位置进行计算

    卷积核的操作：输入图像中的每一个区域都和卷积核做全连接，得到输出图像中的一个区域

    ![image.png](https://upload-images.jianshu.io/upload_images/7220971-cea6f08915418756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    卷积核和输入图像的计算方法：

    ![image.png](https://upload-images.jianshu.io/upload_images/7220971-536f6e3d83d4d83e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



    步长：控制卷积核在图像上每次划动所隔的位置

    padding使输出size变小：

    在刚才的计算中，卷积核在图像划过后产生的输出相对输入来说是逐渐变小的，这个对中间的计算就会比较负责，因为可能会有多个卷积层，如果每层都变小的话，会很难计算。

    那么有没有一种办法，让输入和输出的size是一样的呢--padding

    padding的方法就是说在图像的周围，加上一些默认值0，那么当卷积核在从加过padding图像划过的时候，产生的输出就和原输入的大小是一样的。padding加的大小，就和卷积核是有关的（根据```输出size=输入size-卷积核size+1 ```的这个公式计算），

  - 感悟：实际上一次卷积操作，就是一次特征提取

  - 多通道：卷积也变成多通道的，通道上的卷积的参数是不共享的，在做计算的过程中，每个通道上的卷积的参数和相应图像上的区域做内积，将这三个通道上得到的同样位置上的内积的结果相加起来作为输出神经元的值

  ​       ![image.png](https://upload-images.jianshu.io/upload_images/7220971-b6b34b583d1b4a4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  - 多个卷积核

    如何产生多通道的神经元—多加几个卷积核，这些卷积核的参数是不共享的。多卷积核的物理意义：卷积核是用来提取某种特征的，当这个区域有这个特征的时候，卷积核就能够捕捉到特征使得输出神经元比较大，没有捕捉到，输出就会比较小。多个卷积核可以用来提取多种特征

    ![image.png](https://upload-images.jianshu.io/upload_images/7220971-4abbe081df1f4b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



  - 卷积层的参数数目举例

    卷积层,输入三通道,输出192通道,卷积核大小是3\*3 ,问该卷积层有多少参数?

    ```
    // 3*3 是一个卷积核，因为是三通道的所以再乘3
    // (3*3)*3 是一个卷积层，一共有192通道，就有192层
    (3*(3*3)) * 192 = 5184
    ```

- 激活函数

  除了之前讲过的sigmoid激活函数，常用的还有其他五种

  ![image.png](https://upload-images.jianshu.io/upload_images/7220971-f0a9cec5aad7ccb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  在卷积神经网络中，比较常用的激活函数时ReLU，因为他的计算非常简单（sigmoid需要进行一个非常复杂的指数计算和一个相对复杂的出发计算）

  ![image.png](https://upload-images.jianshu.io/upload_images/7220971-a98d2f8ade3ae28d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  - 激活函数的性质：
    1. 单调性
    2. 非线性函数（面试经常问，划重点！！！）：多个神经元之间的全连接，实际上都是做的矩阵的操作，而矩阵的操作是可以合并的。如果不使用非线性函数，即使很深层次的神经网络，实际上也可以合并成一层，那么这个时候多层就没有意义了
  - 卷积函数参数
    - P = 边距(padding)
    - S = 步长(stride)
    - 输出尺寸=(n-p)/s + 1
    - 参数数目 = kw\*Kh\*Ci·*Co
      - Ci:通道数目
      - Co:输出通道数
      - Kw,Kh: 卷积核长宽

- 池化

  - 最大值池化：

    ![image.png](https://upload-images.jianshu.io/upload_images/7220971-1dea67f8c15c9eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    - 仍然是核在输入图像上划动，但是不是做内积，而是取这个区域像素值的最大值。
    - 做卷积的时候，默认步长=1，池化的时候默认步长和核的宽高是相等（不会重叠）
    - 对于多出来的边的处理方法：忽略和padding

  - 平均值池化:

    - 仍然是核在输入图像上划动，但是不是做内积，而是取这个区域像素值的平均值。

  - 池化的性质与性质：

    - 常使用不重叠（stride=kernel size），不补零（多余的数据直接丢弃）
    - 没有用于求导的参数（直接求最大值或者平均值）
    - 参数为步长和池化核大小（一般是相等，特殊情况下也可以不等）
    - 用于减少图像尺寸，从而减少计算量（在池化后加一层卷积，这次卷积划过图像比较小，节省内存）
    - 一定程度解决平移鲁棒性（卷积的时候由于有重叠，导致平移一小步得等到的结果可能和之前是一样的，池化可以一定程度上解决这个问题）
    - 损失了空间位置精度（池化是计算量和精度直接的权衡）

- 全连接层（和普通神经网络一样）

  - 将上一层输出展开（将图像矩阵展开转换成向量）并连接到每一个神经元上
  - 全连接层后不能再加卷积层和池化层，因为这时候已经把图像打平成向量了
  - 相较于卷积层，参数数量较大
  - 参数数目为Ci\*Co 
    - Ci\Co为输入输出的通道数目

- 卷积神经网络结构

  卷积神经网络=卷积层+池化层+全连接层

  ![image.png](https://upload-images.jianshu.io/upload_images/7220971-161b0f27ca16c5bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

   上图年代较早，图中的单词和我们讲的概念可以先忽略，只看结构的基本信息

  1. 输入是2通道的96*96的图像
  2. 先经过5\*5的卷积核之后，得到的是一个92\*92的8通道的图，这里卷积没有做padding，所以输出的size会变小
  3. 然后经过了一个4\*4的池化，得到了一个23\*23的8通道的结果
  4. 又经过了一个6\*6的卷积核，得到了一个24通道的18\*18的结果
  5. 又经过了一个4\*4的池化，得到了一个23\*23的8通道的结果
  6. 最后经过了一个100参数的全连接层



  由于全连接的结果是向量，是没有办法生成图像的，如果去掉全连接层，我们就可以使得卷积神经网络可以以图像的形式输出模型东西。

  如下输出是和输入同等大小的图像，每个图像上的值就是一个分类信息，用来分类这是不是一个分界面，比如输入是猫和狗，这里就可以把猫和狗区分开来

  问题:不padding的卷积和池化会使得图像变小，如何得到和原图一样大小的输出呢？反卷积，使用小于1的步长，这是一个非常奇怪的卷积操作，会在后面提到

  ![image.png](https://upload-images.jianshu.io/upload_images/7220971-31cf5586196e78d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
